name: etl-pipeline
version: 1.0.0
description: |
  Self-contained ETL data pipeline demonstrating extraction from multiple sources,
  transformation, validation, and loading - all simulated without external dependencies.

inputs:
  pipeline:
    name: "daily-sales-sync"
    targetWarehouse: "analytics_dw"
    batchSize: 1000
    startDate: "2024-01-01"
    endDate: "2024-01-31"
  # Embedded sample data for demonstration
  sampleData:
    orders:
      - id: "ORD-001"
        customer_id: "CUST-101"
        created_at: "2024-01-15T10:30:00Z"
        total: 299.99
        currency: "USD"
        status: "completed"
        line_items: [{sku: "SKU-A", qty: 2}]
        shipping_address: {country: "US"}
        payment: {method: "credit_card"}
      - id: "ORD-002"
        customer_id: "CUST-102"
        created_at: "2024-01-16T14:20:00Z"
        total: 149.50
        currency: "USD"
        status: "completed"
        line_items: [{sku: "SKU-B", qty: 1}, {sku: "SKU-C", qty: 3}]
        shipping_address: {country: "CA"}
        payment: {method: "paypal"}
      - id: "ORD-003"
        customer_id: "CUST-101"
        created_at: "2024-01-20T09:15:00Z"
        total: 599.00
        currency: "USD"
        status: "completed"
        line_items: [{sku: "SKU-D", qty: 1}]
        shipping_address: {country: "US"}
        payment: {method: "credit_card"}
    customers:
      - id: "CUST-101"
        email: "alice@example.com"
        first_name: "Alice"
        last_name: "Johnson"
        address: {country: "US", city: "New York"}
        created_at: "2023-06-15T00:00:00Z"
        total_orders: 15
        total_spent: 2500.00
      - id: "CUST-102"
        email: "bob@example.com"
        first_name: "Bob"
        last_name: "Smith"
        address: {country: "CA", city: "Toronto"}
        created_at: "2023-09-20T00:00:00Z"
        total_orders: 5
        total_spent: 750.00
    products:
      - id: "SKU-A"
        name: "Wireless Mouse"
        category: "Electronics"
        price: 49.99
        inventory: 150
      - id: "SKU-B"
        name: "USB Hub"
        category: "Electronics"
        price: 29.99
        inventory: 200
      - id: "SKU-C"
        name: "Notebook"
        category: "Office"
        price: 12.99
        inventory: 500
      - id: "SKU-D"
        name: "Monitor Stand"
        category: "Office"
        price: 89.99
        inventory: 75

steps:
  # Step 1: Validate pipeline configuration
  - id: validate_config
    activity: validate
    input:
      data: "{{inputs.pipeline}}"
      rules:
        required: ["name", "targetWarehouse", "batchSize"]
        types:
          name: "string"
          batchSize: "number"
        custom: "data.batchSize > 0 && data.batchSize <= 10000"

  # Step 2: Log pipeline start
  - id: log_pipeline_start
    activity: log
    dependsOn: ["validate_config"]
    when: "{{step.validate_config.result.isValid}}"
    input:
      message: "ETL Pipeline started"
      level: "info"
      data:
        pipelineName: "{{inputs.pipeline.name}}"
        startDate: "{{inputs.pipeline.startDate}}"
        endDate: "{{inputs.pipeline.endDate}}"

  # Step 3: Extract orders data
  - id: extract_orders
    type: code
    dependsOn: ["log_pipeline_start"]
    input:
      orders: "{{inputs.sampleData.orders}}"
      startDate: "{{inputs.pipeline.startDate}}"
      endDate: "{{inputs.pipeline.endDate}}"
    code: |
      // Simulate data extraction with filtering
      const records = input.orders.filter(order => {
        const orderDate = new Date(order.created_at);
        return orderDate >= new Date(input.startDate) && orderDate <= new Date(input.endDate);
      });
      
      console.log('Extracted', records.length, 'orders');
      
      return {
        data: { records },
        extractedAt: new Date().toISOString(),
        count: records.length
      };

  # Step 4: Extract customers data
  - id: extract_customers
    type: code
    dependsOn: ["log_pipeline_start"]
    input:
      customers: "{{inputs.sampleData.customers}}"
    code: |
      // Simulate customer data extraction
      const records = input.customers;
      
      console.log('Extracted', records.length, 'customers');
      
      return {
        data: { records },
        extractedAt: new Date().toISOString(),
        count: records.length
      };

  # Step 5: Extract products data
  - id: extract_products
    type: code
    dependsOn: ["log_pipeline_start"]
    input:
      products: "{{inputs.sampleData.products}}"
    code: |
      // Simulate product data extraction
      const records = input.products.filter(p => p.inventory > 0);
      
      console.log('Extracted', records.length, 'active products');
      
      return {
        data: { records },
        extractedAt: new Date().toISOString(),
        count: records.length
      };

  # Step 6: Transform orders data
  - id: transform_orders
    type: code
    dependsOn: ["extract_orders"]
    input:
      rawData: "{{step.extract_orders.result.data}}"
    code: |
      const records = input.rawData.records || [];
      
      const transformed = records.map(order => ({
        order_id: order.id,
        customer_id: order.customer_id,
        order_date: new Date(order.created_at).toISOString().split('T')[0],
        total_amount: parseFloat(order.total) || 0,
        currency: order.currency || 'USD',
        status: order.status.toLowerCase(),
        item_count: order.line_items?.length || 0,
        shipping_country: order.shipping_address?.country || 'Unknown',
        payment_method: order.payment?.method || 'unknown',
        is_high_value: parseFloat(order.total) > 500,
        fiscal_quarter: Math.ceil((new Date(order.created_at).getMonth() + 1) / 3),
        _etl_timestamp: new Date().toISOString()
      }));
      
      const valid = transformed.filter(r => r.order_id && r.customer_id);
      
      console.log('Transformed', valid.length, 'orders');
      
      return {
        records: valid,
        stats: {
          total: records.length,
          valid: valid.length,
          invalid: records.length - valid.length,
          highValueOrders: valid.filter(r => r.is_high_value).length
        }
      };

  # Step 7: Transform customers data
  - id: transform_customers
    type: code
    dependsOn: ["extract_customers"]
    input:
      rawData: "{{step.extract_customers.result.data}}"
    code: |
      const records = input.rawData.records || [];
      
      const transformed = records.map(customer => ({
        customer_id: customer.id,
        email_hash: customer.email ? btoa(customer.email).slice(0, 20) : null,
        first_name: customer.first_name?.trim(),
        last_name: customer.last_name?.trim(),
        country: customer.address?.country || 'Unknown',
        city: customer.address?.city,
        signup_date: new Date(customer.created_at).toISOString().split('T')[0],
        customer_segment: customer.total_orders > 10 ? 'loyal' : 
                         customer.total_orders > 3 ? 'regular' : 'new',
        lifetime_value: parseFloat(customer.total_spent) || 0,
        _etl_timestamp: new Date().toISOString()
      }));
      
      const valid = transformed.filter(r => r.customer_id);
      
      console.log('Transformed', valid.length, 'customers');
      
      return {
        records: valid,
        stats: {
          total: records.length,
          valid: valid.length,
          bySegment: {
            loyal: valid.filter(r => r.customer_segment === 'loyal').length,
            regular: valid.filter(r => r.customer_segment === 'regular').length,
            new: valid.filter(r => r.customer_segment === 'new').length
          }
        }
      };

  # Step 8: Transform products data
  - id: transform_products
    activity: transform
    dependsOn: ["extract_products"]
    input:
      data: "{{step.extract_products.result.data.records}}"
      operations:
        - type: filter
          config:
            expression: "item.price > 0"
        - type: map
          config:
            expression: "({ product_id: item.id, name: item.name, category: item.category, price: item.price, in_stock: item.inventory > 0 })"
        - type: sort
          config:
            field: "category"
            order: "asc"

  # Step 9: Validate transformed data quality
  - id: validate_data_quality
    type: code
    dependsOn: ["transform_orders", "transform_customers", "transform_products"]
    input:
      orders: "{{step.transform_orders.result}}"
      customers: "{{step.transform_customers.result}}"
      products: "{{step.transform_products.result.data}}"
    code: |
      const issues = [];
      
      // Check orders
      if (input.orders.stats.invalid > input.orders.stats.total * 0.1) {
        issues.push('High invalid order rate: ' + input.orders.stats.invalid + '/' + input.orders.stats.total);
      }
      
      // Check for orphan orders
      const customerIds = new Set(input.customers.records.map(c => c.customer_id));
      const orphanOrders = input.orders.records.filter(o => !customerIds.has(o.customer_id));
      if (orphanOrders.length > 0) {
        issues.push('Found ' + orphanOrders.length + ' orders with missing customer references');
      }
      
      const passed = issues.length === 0;
      
      console.log('Data quality check:', passed ? 'PASSED' : 'FAILED');
      
      return {
        passed,
        issues,
        summary: {
          ordersCount: input.orders.stats.valid,
          customersCount: input.customers.stats.valid,
          productsCount: input.products.length
        }
      };

  # Step 10: Load orders to warehouse (simulated)
  - id: load_orders
    type: code
    dependsOn: ["validate_data_quality"]
    when: "{{step.validate_data_quality.result.passed}}"
    input:
      records: "{{step.transform_orders.result.records}}"
      targetWarehouse: "{{inputs.pipeline.targetWarehouse}}"
    code: |
      // Simulate loading to data warehouse
      console.log('Loading', input.records.length, 'orders to', input.targetWarehouse);
      
      return {
        table: 'fact_orders',
        recordsLoaded: input.records.length,
        loadedAt: new Date().toISOString()
      };

  # Step 11: Load customers to warehouse (simulated)
  - id: load_customers
    type: code
    dependsOn: ["validate_data_quality"]
    when: "{{step.validate_data_quality.result.passed}}"
    input:
      records: "{{step.transform_customers.result.records}}"
      targetWarehouse: "{{inputs.pipeline.targetWarehouse}}"
    code: |
      // Simulate loading to data warehouse
      console.log('Loading', input.records.length, 'customers to', input.targetWarehouse);
      
      return {
        table: 'dim_customers',
        recordsLoaded: input.records.length,
        loadedAt: new Date().toISOString()
      };

  # Step 12: Load products to warehouse (simulated)
  - id: load_products
    type: code
    dependsOn: ["validate_data_quality"]
    when: "{{step.validate_data_quality.result.passed}}"
    input:
      records: "{{step.transform_products.result.data}}"
      targetWarehouse: "{{inputs.pipeline.targetWarehouse}}"
    code: |
      // Simulate loading to data warehouse
      console.log('Loading', input.records.length, 'products to', input.targetWarehouse);
      
      return {
        table: 'dim_products',
        recordsLoaded: input.records.length,
        loadedAt: new Date().toISOString()
      };

  # Step 13: Log pipeline completion
  - id: log_pipeline_complete
    activity: log
    dependsOn: ["load_orders", "load_customers", "load_products"]
    input:
      message: "ETL Pipeline completed successfully"
      level: "info"
      data:
        pipelineName: "{{inputs.pipeline.name}}"
        ordersLoaded: "{{step.load_orders.result.recordsLoaded}}"
        customersLoaded: "{{step.load_customers.result.recordsLoaded}}"
        productsLoaded: "{{step.load_products.result.recordsLoaded}}"

  # Step 14: Send completion notification
  - id: send_completion_notification
    activity: email
    dependsOn: ["log_pipeline_complete"]
    input:
      to: "data-team@example.com"
      subject: "ETL Pipeline Complete - {{inputs.pipeline.name}}"
      body: |
        <h1>ETL Pipeline Completed</h1>
        <p><strong>Pipeline:</strong> {{inputs.pipeline.name}}</p>
        <p><strong>Date Range:</strong> {{inputs.pipeline.startDate}} to {{inputs.pipeline.endDate}}</p>
        
        <h2>Summary</h2>
        <ul>
          <li>Orders Loaded: {{step.load_orders.result.recordsLoaded}}</li>
          <li>Customers Loaded: {{step.load_customers.result.recordsLoaded}}</li>
          <li>Products Loaded: {{step.load_products.result.recordsLoaded}}</li>
          <li>Data Quality: PASSED</li>
        </ul>
        
        <p>All data has been loaded to the {{inputs.pipeline.targetWarehouse}} warehouse.</p>
