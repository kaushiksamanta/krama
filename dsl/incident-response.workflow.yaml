name: incident-response
version: 1.0.0
description: |
  Self-contained IT incident response workflow demonstrating incident detection,
  triage, escalation, and resolution tracking - all simulated without external APIs.

inputs:
  incident:
    id: "INC-2024-00567"
    title: "Database connection timeout in production"
    description: "Multiple services reporting database connection failures"
    severity: "high"
    source: "monitoring_system"
    affectedServices:
      - "api-gateway"
      - "user-service"
      - "order-service"
    reportedBy: "automated_alert"
    reportedAt: "2024-01-15T14:30:00Z"
    metadata:
      errorRate: 45.2
      affectedRegion: "us-east-1"
      alertId: "ALT-789012"
  incidentManagerEmail: "incident-manager@example.com"
  stakeholderEmails: "stakeholders@example.com"

steps:
  # Step 1: Validate incident data
  - id: validate_incident
    activity: validate
    input:
      data: "{{inputs.incident}}"
      rules:
        required: ["id", "title", "severity", "affectedServices"]
        types:
          id: "string"
          severity: "string"
          affectedServices: "array"
        custom: "['low', 'medium', 'high', 'critical'].includes(data.severity)"

  # Step 2: Enrich incident with system data
  - id: enrich_incident
    type: code
    dependsOn: ["validate_incident"]
    when: "{{step.validate_incident.result.isValid}}"
    input:
      incident: "{{inputs.incident}}"
    code: |
      const severityPriority = {
        critical: 1,
        high: 2,
        medium: 3,
        low: 4
      };
      
      const slaMinutes = {
        critical: 15,
        high: 60,
        medium: 240,
        low: 1440
      };
      
      const enriched = {
        ...input.incident,
        priority: severityPriority[input.incident.severity] || 4,
        slaDeadline: new Date(Date.now() + slaMinutes[input.incident.severity] * 60000).toISOString(),
        status: 'open',
        assignedTeam: null,
        timeline: [{
          timestamp: new Date().toISOString(),
          action: 'incident_created',
          actor: 'system'
        }]
      };
      
      // Determine on-call team based on affected services
      const serviceTeamMap = {
        'api-gateway': 'platform-team',
        'user-service': 'identity-team',
        'order-service': 'commerce-team',
        'payment-service': 'payments-team',
        'database': 'dba-team'
      };
      
      const teams = new Set(input.incident.affectedServices.map(s => serviceTeamMap[s] || 'platform-team'));
      enriched.assignedTeam = teams.size === 1 ? [...teams][0] : 'platform-team';
      
      console.log('Incident enriched:', enriched.id, 'Priority:', enriched.priority);
      
      return enriched;

  # Step 3: Log incident creation
  - id: log_incident_created
    activity: log
    dependsOn: ["enrich_incident"]
    input:
      message: "Incident created and enriched"
      level: "warn"
      data:
        incidentId: "{{step.enrich_incident.result.id}}"
        severity: "{{step.enrich_incident.result.severity}}"
        priority: "{{step.enrich_incident.result.priority}}"
        assignedTeam: "{{step.enrich_incident.result.assignedTeam}}"

  # Step 4: Get on-call engineer (simulated)
  - id: get_oncall_engineer
    type: code
    dependsOn: ["enrich_incident"]
    input:
      assignedTeam: "{{step.enrich_incident.result.assignedTeam}}"
    code: |
      // Simulated on-call schedule lookup
      const oncallSchedule = {
        'platform-team': { name: 'Alice Chen', email: 'alice.chen@example.com', phone: '+1-555-0101' },
        'identity-team': { name: 'Bob Martinez', email: 'bob.martinez@example.com', phone: '+1-555-0102' },
        'commerce-team': { name: 'Carol Johnson', email: 'carol.johnson@example.com', phone: '+1-555-0103' },
        'payments-team': { name: 'David Kim', email: 'david.kim@example.com', phone: '+1-555-0104' },
        'dba-team': { name: 'Eve Wilson', email: 'eve.wilson@example.com', phone: '+1-555-0105' }
      };
      
      const engineer = oncallSchedule[input.assignedTeam] || oncallSchedule['platform-team'];
      
      console.log('On-call engineer:', engineer.name);
      
      return {
        engineer,
        team: input.assignedTeam,
        retrievedAt: new Date().toISOString()
      };

  # Step 5: Create incident ticket (simulated)
  - id: create_itsm_ticket
    type: code
    dependsOn: ["enrich_incident", "get_oncall_engineer"]
    input:
      incident: "{{step.enrich_incident.result}}"
      oncall: "{{step.get_oncall_engineer.result}}"
    code: |
      // Simulate ITSM ticket creation
      const ticketId = 'TKT-' + Date.now();
      
      const ticket = {
        ticketId,
        externalId: input.incident.id,
        title: input.incident.title,
        description: input.incident.description,
        priority: input.incident.priority,
        assignee: input.oncall.engineer.email,
        team: input.incident.assignedTeam,
        slaDeadline: input.incident.slaDeadline,
        tags: input.incident.affectedServices,
        status: 'open',
        createdAt: new Date().toISOString()
      };
      
      console.log('ITSM ticket created:', ticketId);
      
      return ticket;

  # Step 6: Send incident email notification
  - id: send_incident_email
    activity: email
    dependsOn: ["enrich_incident", "get_oncall_engineer", "create_itsm_ticket"]
    input:
      to: "{{step.get_oncall_engineer.result.engineer.email}}"
      subject: "[{{step.enrich_incident.result.severity}}] Incident: {{step.enrich_incident.result.title}}"
      body: |
        <h1>Incident Alert</h1>
        <table>
          <tr><td><strong>ID:</strong></td><td>{{step.enrich_incident.result.id}}</td></tr>
          <tr><td><strong>Severity:</strong></td><td>{{step.enrich_incident.result.severity}}</td></tr>
          <tr><td><strong>Priority:</strong></td><td>P{{step.enrich_incident.result.priority}}</td></tr>
          <tr><td><strong>SLA Deadline:</strong></td><td>{{step.enrich_incident.result.slaDeadline}}</td></tr>
          <tr><td><strong>Assigned Team:</strong></td><td>{{step.enrich_incident.result.assignedTeam}}</td></tr>
          <tr><td><strong>Ticket:</strong></td><td>{{step.create_itsm_ticket.result.ticketId}}</td></tr>
        </table>
        
        <h2>Description</h2>
        <p>{{step.enrich_incident.result.description}}</p>
        
        <h2>Affected Services</h2>
        <p>{{step.enrich_incident.result.affectedServices}}</p>

  # Step 7: Run automated diagnostics (simulated)
  - id: run_diagnostics
    type: code
    dependsOn: ["enrich_incident"]
    input:
      incident: "{{step.enrich_incident.result}}"
    code: |
      // Simulate automated diagnostics
      const diagnosticResults = input.incident.affectedServices.map(service => {
        // Simulate various check results
        const checks = [
          { name: 'connectivity', status: Math.random() > 0.3 ? 'passed' : 'failed', message: 'Network connectivity check' },
          { name: 'resource_usage', status: 'warning', message: 'High CPU usage detected', details: { cpu: 85, memory: 72 } },
          { name: 'error_logs', status: 'warning', message: 'Elevated error rate', details: { errorCount: 150, timeWindow: '5m' } },
          { name: 'recent_deployments', status: 'passed', message: 'No recent deployments', details: { deployedWithin24h: false } }
        ];
        
        return { service, checks };
      });
      
      console.log('Diagnostics completed for', diagnosticResults.length, 'services');
      
      return {
        results: diagnosticResults.flatMap(r => r.checks),
        services: diagnosticResults,
        completedAt: new Date().toISOString()
      };

  # Step 8: Analyze diagnostics results
  - id: analyze_diagnostics
    type: code
    dependsOn: ["run_diagnostics"]
    input:
      diagnostics: "{{step.run_diagnostics.result}}"
    code: |
      const results = input.diagnostics.results || [];
      const findings = [];
      const recommendations = [];
      
      results.forEach(check => {
        if (check.status === 'failed' || check.status === 'warning') {
          findings.push({
            check: check.name,
            status: check.status,
            message: check.message,
            details: check.details
          });
          
          if (check.name === 'connectivity' && check.status === 'failed') {
            recommendations.push('Check network connectivity and firewall rules');
          }
          if (check.name === 'resource_usage' && check.details?.cpu > 80) {
            recommendations.push('High CPU usage detected - consider scaling up');
          }
          if (check.name === 'recent_deployments' && check.details?.deployedWithin24h) {
            recommendations.push('Recent deployment detected - consider rollback');
          }
        }
      });
      
      const rootCauseCandidate = findings.length > 0 ? findings[0].check : 'unknown';
      
      console.log('Analysis complete. Findings:', findings.length);
      
      return {
        findings,
        recommendations,
        rootCauseCandidate,
        requiresManualInvestigation: findings.length === 0 || recommendations.length === 0,
        analysisTimestamp: new Date().toISOString()
      };

  # Step 9: Update ticket with diagnostics
  - id: update_ticket_diagnostics
    type: code
    dependsOn: ["analyze_diagnostics", "create_itsm_ticket"]
    input:
      analysis: "{{step.analyze_diagnostics.result}}"
      ticketId: "{{step.create_itsm_ticket.result.ticketId}}"
    code: |
      // Simulate ticket update
      const comment = {
        ticketId: input.ticketId,
        type: 'diagnostics_update',
        content: 'Automated diagnostics completed. Findings: ' + input.analysis.findings.length + '. Root cause candidate: ' + input.analysis.rootCauseCandidate,
        recommendations: input.analysis.recommendations,
        addedAt: new Date().toISOString()
      };
      
      console.log('Ticket updated with diagnostics');
      
      return comment;

  # Step 10: Wait for acknowledgment signal
  - id: await_acknowledgment
    type: signal
    dependsOn: ["send_incident_email"]

  # Step 11: Log acknowledgment
  - id: log_acknowledgment
    activity: log
    dependsOn: ["await_acknowledgment"]
    input:
      message: "Incident acknowledged"
      level: "info"
      data:
        incidentId: "{{step.enrich_incident.result.id}}"
        acknowledgedBy: "{{step.await_acknowledgment.result.acknowledgedBy}}"

  # Step 12: Wait for resolution signal
  - id: await_resolution
    type: signal
    dependsOn: ["log_acknowledgment"]

  # Step 13: Process resolution
  - id: process_resolution
    type: code
    dependsOn: ["await_resolution", "enrich_incident"]
    input:
      incident: "{{step.enrich_incident.result}}"
      resolution: "{{step.await_resolution.result}}"
    code: |
      const incident = input.incident;
      const resolution = input.resolution;
      
      const resolvedIncident = {
        ...incident,
        status: 'resolved',
        resolvedAt: new Date().toISOString(),
        resolution: {
          summary: resolution.summary || 'Issue resolved',
          rootCause: resolution.rootCause || 'Under investigation',
          remediation: resolution.remediation || 'Applied fix',
          resolvedBy: resolution.resolvedBy || 'on-call engineer'
        },
        metrics: {
          slaBreached: new Date() > new Date(incident.slaDeadline)
        }
      };
      
      console.log('Incident resolved:', resolvedIncident.id);
      console.log('SLA Breached:', resolvedIncident.metrics.slaBreached);
      
      return resolvedIncident;

  # Step 14: Close ITSM ticket
  - id: close_itsm_ticket
    type: code
    dependsOn: ["process_resolution", "create_itsm_ticket"]
    input:
      resolution: "{{step.process_resolution.result}}"
      ticketId: "{{step.create_itsm_ticket.result.ticketId}}"
    code: |
      // Simulate ticket closure
      const closedTicket = {
        ticketId: input.ticketId,
        status: 'resolved',
        resolution: input.resolution.resolution.summary,
        rootCause: input.resolution.resolution.rootCause,
        closedAt: new Date().toISOString()
      };
      
      console.log('Ticket closed:', closedTicket.ticketId);
      
      return closedTicket;

  # Step 15: Send resolution notification
  - id: send_resolution_notification
    activity: email
    dependsOn: ["process_resolution"]
    input:
      to: "{{inputs.stakeholderEmails}}"
      subject: "[RESOLVED] {{step.enrich_incident.result.title}}"
      body: |
        <h1>Incident Resolved</h1>
        <p>The following incident has been resolved:</p>
        
        <table>
          <tr><td><strong>ID:</strong></td><td>{{step.enrich_incident.result.id}}</td></tr>
          <tr><td><strong>Title:</strong></td><td>{{step.enrich_incident.result.title}}</td></tr>
          <tr><td><strong>Resolved By:</strong></td><td>{{step.process_resolution.result.resolution.resolvedBy}}</td></tr>
        </table>
        
        <h2>Resolution Summary</h2>
        <p>{{step.process_resolution.result.resolution.summary}}</p>
        
        <h2>Root Cause</h2>
        <p>{{step.process_resolution.result.resolution.rootCause}}</p>

  # Step 16: Log incident closure
  - id: log_incident_closed
    activity: log
    dependsOn: ["close_itsm_ticket", "send_resolution_notification"]
    input:
      message: "Incident closed"
      level: "info"
      data:
        incidentId: "{{step.enrich_incident.result.id}}"
        resolution: "{{step.process_resolution.result.resolution.summary}}"
        slaBreached: "{{step.process_resolution.result.metrics.slaBreached}}"
